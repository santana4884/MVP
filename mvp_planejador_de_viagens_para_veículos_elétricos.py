# -*- coding: utf-8 -*-
"""MVP: Planejador de Viagens para Ve√≠culos El√©tricos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rbSybCTcJI0MXL-Nj3OkTzgwWvthyh9l

# MVP: Planejador de Viagens para Ve√≠culos El√©tricos

**Nome:** Seu Nome Completo  
**Matr√≠cula:** Sua Matr√≠cula

---

## 1. Introdu√ß√£o e Defini√ß√£o do Problema

Com o crescimento do mercado de ve√≠culos el√©tricos (VEs), uma das maiores preocupa√ß√µes dos consumidores √© a "ansiedade de autonomia" (range anxiety), o medo de ficar sem bateria durante uma viagem. A viabilidade de viagens de longa dist√¢ncia no Brasil depende diretamente da exist√™ncia e distribui√ß√£o de uma infraestrutura de recarga robusta.

O objetivo deste projeto √© analisar a base de dados do Open Charge Map para entender a distribui√ß√£o, densidade e caracter√≠sticas das esta√ß√µes de recarga no Brasil e, a partir dessa an√°lise, desenvolver uma ferramenta interativa para simular a viabilidade de rotas.

### 1.1. Hip√≥teses Iniciais
* **H1:** A infraestrutura de recarga √© massivamente concentrada nas regi√µes Sul e Sudeste do Brasil.
* **H2:** A rede de carregadores r√°pidos (DC), essencial para viagens, √© escassa ou de dif√≠cil acesso p√∫blico.
* **H3:** Rotas entre grandes capitais como S√£o Paulo e Rio de Janeiro s√£o vi√°veis, mesmo considerando apenas carregadores de recarga mais lenta (AC).

### 1.2. Fonte e Descri√ß√£o dos Dados
Os dados foram coletados via API do **Open Charge Map (OCM)**, uma base de dados global e colaborativa de pontos de recarga. Foram extra√≠dos todos os pontos localizados no Brasil na data de 01/07/2025, totalizando 514 registros iniciais. Os principais atributos analisados foram a localiza√ß√£o (`AddressInfo`), o tipo de acesso (`UsageType`) e o status operacional (`StatusType`).

# 2. Importa√ß√£o das Bibliotecas Necess√°rias e Carga de Dados

Esta se√ß√£o consolida todas as importa√ß√µes de bibliotecas necess√°rias para a an√°lise, visualiza√ß√£o e pr√©-processamento dos dados, bem como o carregamento inicial dos dados da API do Open Charge Map (OCM)

### 2.1. Instala√ß√£o de Bibliotecas Adicionais
"""

print("Instalando bibliotecas necess√°rias...")
!pip install openrouteservice -q
!pip install shapely -q
print("‚úÖ Bibliotecas prontas.")

"""### 2.2. Importa√ß√£o de Todas as Bibliotecas"""

print("Importando Bibliotecas necess√°rias...")
import pandas as pd
import numpy as np
import math
import requests
import folium
import openrouteservice
import ipywidgets as widgets
from IPython.display import display
from shapely.geometry import Point, LineString
from geopy.distance import geodesic
import matplotlib.pyplot as plt
import seaborn as sns
import ast
import plotly.graph_objects as go
import time

# Habilita o gerenciador de widgets para o Google Colab
from google.colab import output
output.enable_custom_widget_manager()
print("‚úÖ Bibliotecas Importadas.")

"""2.3. Carregamento dos Dados da API Open Charge Map"""

api_key = "3911ea9f-e173-415f-995a-4b8b8140012c"
url = f'https://api.openchargemap.io/v3/poi/?output=json&countrycode=BR&maxresults=10000&key={api_key}'

print("\nBuscando dados da API do Open Charge Map para importar no gitHub...")
try:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()
    # Cria o DataFrame principal que ser√° usado em todo o projeto
    df = pd.json_normalize(data)
    print(f"‚úÖ Sucesso! {len(df)} registros de pontos de recarga foram carregados para o Brasil.")
except Exception as e:
    print(f"‚ùå Erro ao buscar dados da API: {e}")

df.to_csv('dataset_carregadores_brasil.csv', index=False)
print("Arquivo 'dataset_carregadores_brasil.csv' criado com sucesso!")

url_dataset = 'https://raw.githubusercontent.com/santana4884/MVP-_Planejador_de_Viagens_para_Ve-culos_El-tricos/refs/heads/main/dataset_carregadores_brasil.csv'

print("Carregando dataset a partir do reposit√≥rio no GitHub...")
try:
    # Cria o DataFrame principal a partir do arquivo CSV do seu reposit√≥rio
    df = pd.read_csv(url_dataset)
    print(f"‚úÖ Sucesso! {len(df)} registros carregados do seu reposit√≥rio.")
except Exception as e:
    print(f"‚ùå Erro ao carregar o dataset do GitHub: {e}")
    print("Verifique se a URL raw est√° correta e se o arquivo CSV est√° no seu reposit√≥rio.")

"""## 3. An√°lise Explorat√≥ria e Limpeza dos Dados
Nesta se√ß√£o, realizamos uma an√°lise inicial para entender a estrutura dos dados e identificar inconsist√™ncias, aplicando as corre√ß√µes necess√°rias para garantir a qualidade das an√°lises futuras.

### 3.1. Distribui√ß√£o Geogr√°fica Geral dos Pontos de Recarga

Ap√≥s a carga inicial e a verifica√ß√£o da estrutura dos dados, o primeiro passo da nossa explora√ß√£o √© visualizar a distribui√ß√£o geogr√°fica de todos os pontos de recarga no Brasil. Um mapa interativo nos permite ter uma percep√ß√£o imediata da densidade da infraestrutura e validar visualmente nossa primeira hip√≥tese sobre a concentra√ß√£o regional.
"""

import plotly.express as px

print("Gerando mapa interativo de distribui√ß√£o geogr√°fica...")

# Usando o DataFrame 'df' inicial, antes de qualquer filtro
fig = px.scatter_mapbox(df,
                        lat="AddressInfo.Latitude",
                        lon="AddressInfo.Longitude",
                        hover_name="AddressInfo.Title",
                        hover_data={"AddressInfo.Town": True, "OperatorInfo.Title": True, "AddressInfo.StateOrProvince": True},
                        color_discrete_sequence=["#0047AB"],
                        zoom=3,
                        height=500,
                        title="Distribui√ß√£o de Carregadores de VE no Brasil")

fig.update_layout(mapbox_style="open-street-map")
fig.update_layout(margin={"r":0,"t":50,"l":0,"b":0}, title_font_size=20)
fig.show()

"""### An√°lise do Mapa de Distribui√ß√£o

* **Confirma√ß√£o da Hip√≥tese 1:** O mapa confirma de forma contundente a hip√≥tese de que a infraestrutura de recarga √© massivamente concentrada nas regi√µes Sul e Sudeste, com um claro adensamento no eixo litor√¢neo e nas capitais.
* **Identifica√ß√£o de "Desertos de Recarga":** √â not√°vel a escassez de pontos nas vastas √°reas das regi√µes Norte, Nordeste e Centro-Oeste, o que indica um grande desafio para a viabilidade de viagens el√©tricas nessas localidades. Esta visualiza√ß√£o inicial j√° direciona o foco da nossa an√°lise para as disparidades regionais.

### 3.2. Padroniza√ß√£o dos Nomes dos Estados
"""

print("Verificando a consist√™ncia dos nomes dos estados...")
# Remove espa√ßos em branco extras no in√≠cio e no fim
df['AddressInfo.StateOrProvince'] = df['AddressInfo.StateOrProvince'].str.strip()

# Mapa de corre√ß√£o para padronizar os nomes e siglas
mapa_de_correcao = {
    # S√£o Paulo
    'SP': 'S√£o Paulo', 'Sao Paulo': 'S√£o Paulo', 'sao paulo': 'S√£o Paulo', 'Sp': 'S√£o Paulo',
    'Regi√£o Metropolitana de S√£o Paulo': 'S√£o Paulo', 'Indaiatuba - SP': 'S√£o Paulo', 'S√£o paulo': 'S√£o Paulo',

    # Rio de Janeiro
    'RJ': 'Rio de Janeiro', 'rio de janeiro': 'Rio de Janeiro', 'Too de Janeiro': 'Rio de Janeiro', # Corrigindo o erro de digita√ß√£o

    # Paran√°
    'Parana': 'Paran√°', 'PR': 'Paran√°', 'paran√°': 'Paran√°',

    # Santa Catarina
    'SC': 'Santa Catarina',

    # Rio Grande do Sul
    'rio grande do sul': 'Rio Grande do Sul', 'RS': 'Rio Grande do Sul', 'R√≠o Grande do Sul': 'Rio Grande do Sul',
    'Metropolitan Region of Porto Alegre': 'Rio Grande do Sul',

    # Minas Gerais
    'mg': 'Minas Gerais', 'MG': 'Minas Gerais', 'minas gerais': 'Minas Gerais',

    # Bahia
    'Barreiras - BA': 'Bahia', 'BA': 'Bahia',

    # Piau√≠
    'CORRENTE/PI': 'Piau√≠', 'Piaui': 'Piau√≠', 'PI': 'Piau√≠',

    # Maranh√£o
    'MA': 'Maranh√£o',

    # Sergipe
    'SE': 'Sergipe',

    # Rio Grande do Norte
    'RN': 'Rio Grande do Norte',

    # Cear√°
    'Ceara': 'Cear√°', 'CE': 'Cear√°',

    # Alagoas
    'AL': 'Alagoas',

    # Pernambuco
    'PE': 'Pernambuco',

    # Para√≠ba
    'PB': 'Para√≠ba', 'Regi√£o Metropolitana de Campina Grande': 'Para√≠ba',
    'Regi√£o Metropolitana de Guarabira': 'Para√≠ba',

    # Goi√°s
    'Goias': 'Goi√°s', 'GO': 'Goi√°s',

    # Distrito Federal
    'Federal District': 'Distrito Federal'
}

# Aplica as corre√ß√µes
df['AddressInfo.StateOrProvince'] = df['AddressInfo.StateOrProvince'].replace(mapa_de_correcao)

print("‚úÖ Limpeza dos nomes dos estados conclu√≠da.")

"""### 3.3. Gr√°fico de Esta√ß√µes por Estado"""

print("Gerando gr√°fico com dados padronizados...")
plt.figure(figsize=(18, 8))
sns.countplot(y=df['AddressInfo.StateOrProvince'], order=df['AddressInfo.StateOrProvince'].value_counts().index, palette='viridis')
plt.title('N√∫mero de Esta√ß√µes de Recarga por Estado', fontsize=16)
plt.xlabel('Contagem de Esta√ß√µes', fontsize=12)
plt.ylabel('Estado', fontsize=12)
for index, value in enumerate(df['AddressInfo.StateOrProvince'].value_counts()):
    plt.text(value, index, f' {value}', va='center', fontsize=10)
plt.tight_layout()
plt.show()

"""## 4. Pr√©-processamento para Simula√ß√£o de Viagem
Com os dados gerais analisados, agora vamos prepar√°-los para a nossa simula√ß√£o, filtrando apenas os carregadores que seriam √∫teis para um viajante.
"""

print("Iniciando a filtragem de carregadores para um cen√°rio de viagem...")
print("-" * 50)
total_carregadores = len(df)
print(f"Dataset original com {total_carregadores} carregadores.")

# Filtro 1: Manter apenas carregadores operacionais
df_operacional = df[df['StatusType.IsOperational'] == True].copy()
operacionais_count = len(df_operacional)
print(f"Ap√≥s filtro de operacionais, restam {operacionais_count} carregadores.")

# Filtro 2: Manter apenas carregadores de acesso p√∫blico
df_publico = df_operacional[df_operacional['UsageType.Title'] == 'Public'].copy()
publicos_count = len(df_publico)
print(f"Ap√≥s filtro de acesso p√∫blico, restam {publicos_count} carregadores.")

# An√°lise de Carregadores R√°pidos (DC)
# O c√≥digo abaixo analisa a disponibilidade de carregadores DC
def parse_connections(connections_str):
    try: return ast.literal_eval(str(connections_str))
    except: return []

df_publico['Connections_list'] = df_publico['Connections'].apply(parse_connections)
df_exploded = df_publico.explode('Connections_list').dropna(subset=['Connections_list'])
df_normalized_connections = pd.json_normalize(df_exploded['Connections_list']).add_prefix('Conn.')
df_full_connections = pd.concat([df_exploded.reset_index(drop=True), df_normalized_connections.reset_index(drop=True)], axis=1)
df_dc_chargers = df_full_connections[df_full_connections['Conn.ConnectionType.Title'].str.contains('DC', na=False)]
unique_dc_charger_ids = df_dc_chargers['ID'].unique()
df_viagem_dc = df_publico[df_publico['ID'].isin(unique_dc_charger_ids)].copy()
dc_count = len(df_viagem_dc)

print(f"\nAn√°lise de Carregadores R√°pidos (DC): Foram encontrados {dc_count} carregadores DC p√∫blicos e operacionais.")
print("Esta descoberta cr√≠tica (SINAL VERMELHO para viagens r√°pidas) guiar√° nossa simula√ß√£o para o cen√°rio de carregadores AC.")
print("-" * 50)

# Prepara√ß√£o dos dados para o gr√°fico de funil
etapas = ['Total de Carregadores', 'Operacionais', 'Acesso P√∫blico', 'Carga R√°pida (DC)']
valores = [total_carregadores, operacionais_count, publicos_count, dc_count]

# Cria a figura
fig = go.Figure(go.Funnel(
    y = etapas,
    x = valores,
    textposition = "inside",
    textinfo = "value+percent initial",
    opacity = 0.65,
    marker = {"color": ["#4A235A", "#6C3483", "#8E44AD", "#D2B4DE"],
              "line": {"width": [2, 2, 2, 2], "color": ["#3B0B39", "#4A235A", "#6C3483", "#8E44AD"]}},
    connector = {"line": {"color": "royalblue", "dash": "dot", "width": 3}}
))

# Personaliza√ß√£o do layout
fig.update_layout(
    title={
        'text': "Gr√°fico de Filtragem de Carregadores para Viagem",
        'y':0.9,
        'x':0.5,
        'xanchor': 'center',
        'yanchor': 'top'
    },
    font=dict(
        family="Arial, sans-serif",
        size=14,
        color="RebeccaPurple"
    )
)
fig.show()

"""## 5. Desenvolvimento do Planejador de Rotas Interativo

Com os dados analisados e preparados, o passo final √© consolidar nossa l√≥gica em uma ferramenta interativa. Esta se√ß√£o cont√©m o prot√≥tipo funcional do planejador de rotas. A ferramenta permite que o usu√°rio insira uma cidade de origem e destino, defina a autonomia de seu ve√≠culo e simule a viabilidade da viagem.

O aplicativo utiliza a API do OpenRouteService para:
1.  **Geocodificar:** Converter os nomes das cidades em coordenadas geogr√°ficas.
2.  **Roteirizar:** Tra√ßar a rota real ao longo das estradas existentes.

A simula√ß√£o ent√£o analisa a rota, identifica os carregadores dispon√≠veis e fornece um relat√≥rio de viabilidade para cada segmento da viagem, culminando em um mapa interativo com o trajeto.

### 5.1. Defini√ß√£o de Todas as Fun√ß√µes Auxiliares
"""

# Configura√ß√£o do cliente da API do OpenRouteService
ors_api_key = '5b3ce3597851110001cf624873fa4cab1c4946f9b5b642c29b34621c'
ors_client = openrouteservice.Client(key=ors_api_key)

def obter_coordenadas_por_endereco(client, endereco):
    """Converte um nome de cidade/endere√ßo em coordenadas (lat, lon)."""
    try:
        geocode_result = client.pelias_search(text=endereco, size=1)
        if not geocode_result['features']:
            print(f"üî¥ Endere√ßo n√£o encontrado: {endereco}")
            return None
        lon, lat = geocode_result['features'][0]['geometry']['coordinates']
        return (lat, lon)
    except Exception as e:
        print(f"Erro na geocodifica√ß√£o: {e}")
        return None

def obter_rota_real(client, coord_origem, coord_destino):
    """Pede a rota real para a API do ORS."""
    coords = ((coord_origem[1], coord_origem[0]), (coord_destino[1], coord_destino[0]))
    try:
        route = client.directions(coordinates=coords, profile='driving-car', format='geojson')
        route_line = LineString(route['features'][0]['geometry']['coordinates'])
        distancia_total_km = route['features'][0]['properties']['summary']['distance'] / 1000
        route_coords_latlon = [(p[1], p[0]) for p in route_line.coords]
        return {"line": LineString(route_coords_latlon), "distancia_km": distancia_total_km, "coords": route_coords_latlon}
    except Exception as e:
        print(f"Erro ao obter rota da API: {e}")
        return None

def simular_viagem_na_rota(rota, autonomia_km, df_carregadores):
    """Simula a viagem e imprime o status de cada segmento."""
    carregadores_na_rota = []
    for _, carregador in df_carregadores.iterrows():
        ponto_carregador = Point(carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])
        if rota['line'].distance(ponto_carregador) * 111 <= 10: # Raio de 10km da rota
            carregadores_na_rota.append(carregador)

    df_carregadores_filtrados = pd.DataFrame(carregadores_na_rota)
    if df_carregadores_filtrados.empty:
        print("üî¥ Nenhum carregador encontrado pr√≥ximo √† rota da estrada.")
        return {"viagem_viavel": False}

    print(f"Encontrados {len(df_carregadores_filtrados)} carregadores ao longo da estrada.")
    caminho_percorrido_coords = [rota['coords'][0]]
    viagem_viavel = True
    segmento_num = 1
    while True:
        localizacao_atual = caminho_percorrido_coords[-1]
        distancia_restante_total = geodesic(localizacao_atual, rota['coords'][-1]).kilometers
        print(f"\n--- Segmento {segmento_num} ---")
        print(f"Partindo de: {np.round(localizacao_atual, 2)}. Faltam {int(distancia_restante_total)} km.")
        if distancia_restante_total <= autonomia_km:
            print("Resultado: üü¢ VERDE - Destino final ao alcance da autonomia atual!")
            break
        paradas_possiveis = []
        for _, carregador in df_carregadores_filtrados.iterrows():
            coord_carregador = (carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])
            dist_ate_carregador = geodesic(localizacao_atual, coord_carregador).kilometers
            if dist_ate_carregador > 0 and dist_ate_carregador <= autonomia_km and geodesic(coord_carregador, rota['coords'][-1]).kilometers < distancia_restante_total:
                paradas_possiveis.append(carregador)
        num_paradas = len(paradas_possiveis)
        if num_paradas == 0:
            print(f"Resultado: üî¥ VERMELHO - Falha! N√£o foi poss√≠vel encontrar uma pr√≥xima parada ao alcance.")
            viagem_viavel = False
            distancias_proximos_pontos = []
            for _, carregador in df_carregadores_filtrados.iterrows():
                if geodesic( (carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude']), rota['coords'][-1]).kilometers < distancia_restante_total:
                    distancias_proximos_pontos.append(geodesic(localizacao_atual, (carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])).kilometers)
            autonomia_minima = min(distancias_proximos_pontos) if distancias_proximos_pontos else distancia_restante_total
            return {"viagem_viavel": False, "autonomia_minima": math.ceil(autonomia_minima)}
        elif num_paradas <= 2:
            print(f"Resultado: üü° AMARELO - Apenas {num_paradas} op√ß√£o(√µes) de recarga. Planeje com cuidado.")
        else:
            print(f"Resultado: üü¢ VERDE - {num_paradas} op√ß√µes de recarga. Boa cobertura.")
        paradas_possiveis_df = pd.DataFrame(paradas_possiveis)
        paradas_possiveis_df['dist'] = paradas_possiveis_df.apply(lambda row: geodesic(localizacao_atual, (row['AddressInfo.Latitude'], row['AddressInfo.Longitude'])).kilometers, axis=1)
        proxima_parada_info = paradas_possiveis_df.sort_values('dist').iloc[0]
        caminho_percorrido_coords.append((proxima_parada_info['AddressInfo.Latitude'], proxima_parada_info['AddressInfo.Longitude']))
        segmento_num += 1
    caminho_percorrido_coords.append(rota['coords'][-1])
    print("\n--- Relat√≥rio Final da Viagem ---")
    if viagem_viavel: print("‚úÖ Simula√ß√£o conclu√≠da com sucesso!")
    return {"viagem_viavel": True, "caminho_coords": caminho_percorrido_coords, "carregadores_encontrados_df": df_carregadores_filtrados, "rota_completa_coords": rota['coords']}

def desenhar_mapa_folium_real(resultado_simulacao):
    """Recebe o resultado da simula√ß√£o e desenha um mapa limpo."""
    rota_completa = resultado_simulacao["rota_completa_coords"]
    df_carregadores_na_rota = resultado_simulacao["carregadores_encontrados_df"]
    avg_lat = np.mean([p[0] for p in rota_completa]); avg_lon = np.mean([p[1] for p in rota_completa])
    mapa = folium.Map(location=[avg_lat, avg_lon], zoom_start=8, height=600)
    folium.PolyLine(rota_completa, color="#007BFF", weight=5, opacity=0.8, popup="Rota da Estrada").add_to(mapa)
    folium.Marker(rota_completa[0], popup="Origem", icon=folium.Icon(color='green', icon='play')).add_to(mapa)
    folium.Marker(rota_completa[-1], popup="Destino", icon=folium.Icon(color='red', icon='stop')).add_to(mapa)
    if not df_carregadores_na_rota.empty:
        for _, carregador in df_carregadores_na_rota.iterrows():
            folium.CircleMarker(location=[carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude']], radius=5, color='#003366', fill=True, fill_color='#003366', popup=carregador['AddressInfo.Title']).add_to(mapa)
    return mapa

"""### 5.2. Interface Interativa do Planejador"""

df_para_simulacao = df_publico.copy()

# Sua chave da API do OpenRouteService.
ors_api_key = '5b3ce3597851110001cf624873fa4cab1c4946f9b5b642c29b34621c'

# Cria o cliente da API
ors_client = openrouteservice.Client(key=ors_api_key)


# FUN√á√ïES DE API (Geocodifica√ß√£o e Rota)
def obter_coordenadas_por_endereco(client, endereco):
    """Converte um nome de cidade/endere√ßo em coordenadas (lat, lon)."""
    try:
        geocode_result = client.pelias_search(text=endereco, size=1)
        if not geocode_result['features']:
            print(f"üî¥ Endere√ßo n√£o encontrado: {endereco}")
            return None
        lon, lat = geocode_result['features'][0]['geometry']['coordinates']
        return (lat, lon)
    except Exception as e:
        print(f"Erro na geocodifica√ß√£o: {e}")
        return None

def obter_nome_local_por_coord(client, coord):
    """Converte coordenadas (lat, lon) em um nome de local."""
    try:
        # Formato para a API √© (longitude, latitude)
        reverse_result = client.pelias_reverse(point=(coord[1], coord[0]), size=1)
        if not reverse_result['features']:
            return f"Coordenadas {np.round(coord, 2)}" # Fallback
        return reverse_result['features'][0]['properties'].get('label', f"Coordenadas {np.round(coord, 2)}")
    except Exception:
        return f"Coordenadas {np.round(coord, 2)}"

def obter_rota_real(client, coord_origem, coord_destino):
    """Pede a rota real para a API do ORS."""
    coords = ((coord_origem[1], coord_origem[0]), (coord_destino[1], coord_destino[0]))
    try:
        route = client.directions(coordinates=coords, profile='driving-car', format='geojson')
        route_line = LineString(route['features'][0]['geometry']['coordinates'])
        distancia_total_km = route['features'][0]['properties']['summary']['distance'] / 1000
        route_coords_latlon = [(p[1], p[0]) for p in route_line.coords]
        return {"line": LineString(route_coords_latlon), "distancia_km": distancia_total_km, "coords": route_coords_latlon}
    except Exception as e:
        print(f"Erro ao obter rota da API: {e}")
        return None

def simular_viagem_na_rota(rota, autonomia_km, df_carregadores):
    carregadores_na_rota = []
    for _, carregador in df_carregadores.iterrows():
        ponto_carregador = Point(carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])
        if rota['line'].distance(ponto_carregador) * 111 <= 10:
            carregadores_na_rota.append(carregador)

    df_carregadores_filtrados = pd.DataFrame(carregadores_na_rota)
    if df_carregadores_filtrados.empty:
        print("üî¥ Nenhum carregador encontrado pr√≥ximo √† rota da estrada.")
        return {"viagem_viavel": False}

    print(f"Encontrados {len(df_carregadores_filtrados)} carregadores ao longo da estrada.")
    caminho_percorrido_coords = [rota['coords'][0]]
    viagem_viavel = True
    segmento_num = 1

    while True:
        localizacao_atual = caminho_percorrido_coords[-1]
        distancia_restante_total = geodesic(localizacao_atual, rota['coords'][-1]).kilometers

        # OBT√âM O NOME DO LOCAL ATUAL ANTES DE IMPRIMIR
        nome_local_atual = obter_nome_local_por_coord(ors_client, localizacao_atual)

        print(f"\n--- Segmento {segmento_num} ---")
        # USA O NOME DO LOCAL NA MENSAGEM
        print(f"Partindo de: {nome_local_atual}. Faltam {int(distancia_restante_total)} km.")

        if distancia_restante_total <= autonomia_km:
            print("Resultado: üü¢ VERDE - Destino final ao alcance da autonomia atual!")
            break

        paradas_possiveis = []
        for _, carregador in df_carregadores_filtrados.iterrows():
            coord_carregador = (carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])
            dist_ate_carregador = geodesic(localizacao_atual, coord_carregador).kilometers
            if dist_ate_carregador > 0 and dist_ate_carregador <= autonomia_km and geodesic(coord_carregador, rota['coords'][-1]).kilometers < distancia_restante_total:
                paradas_possiveis.append(carregador)

        num_paradas = len(paradas_possiveis)
        if num_paradas == 0:
            print(f"Resultado: üî¥ VERMELHO - Falha! N√£o foi poss√≠vel encontrar uma pr√≥xima parada ao alcance.")
            viagem_viavel = False
            distancias_proximos_pontos = []
            for _, carregador in df_carregadores_filtrados.iterrows():
                if geodesic((carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude']), rota['coords'][-1]).kilometers < distancia_restante_total:
                    distancias_proximos_pontos.append(geodesic(localizacao_atual, (carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude'])).kilometers)
            autonomia_minima = min(distancias_proximos_pontos) if distancias_proximos_pontos else distancia_restante_total
            return {"viagem_viavel": False, "autonomia_minima": math.ceil(autonomia_minima)}
        elif num_paradas <= 2:
            print(f"Resultado: üü° AMARELO - Apenas {num_paradas} op√ß√£o(√µes) de recarga.")
        else:
            print(f"Resultado: üü¢ VERDE - {num_paradas} op√ß√µes de recarga.")

        paradas_possiveis_df = pd.DataFrame(paradas_possiveis)
        paradas_possiveis_df['dist'] = paradas_possiveis_df.apply(lambda row: geodesic(localizacao_atual, (row['AddressInfo.Latitude'], row['AddressInfo.Longitude'])).kilometers, axis=1)
        proxima_parada_info = paradas_possiveis_df.sort_values('dist').iloc[0]
        caminho_percorrido_coords.append((proxima_parada_info['AddressInfo.Latitude'], proxima_parada_info['AddressInfo.Longitude']))
        segmento_num += 1

    caminho_percorrido_coords.append(rota['coords'][-1])
    print("\n--- Relat√≥rio Final da Viagem ---")
    if viagem_viavel: print("‚úÖ Simula√ß√£o conclu√≠da com sucesso!")

    return {"viagem_viavel": True, "caminho_coords": caminho_percorrido_coords, "carregadores_encontrados_df": df_carregadores_filtrados, "rota_completa_coords": rota['coords']}

def desenhar_mapa_folium_real(resultado_simulacao):
    caminho_paradas = resultado_simulacao["caminho_coords"]
    rota_completa = resultado_simulacao["rota_completa_coords"]
    df_carregadores_na_rota = resultado_simulacao["carregadores_encontrados_df"]
    avg_lat = np.mean([p[0] for p in rota_completa])
    avg_lon = np.mean([p[1] for p in rota_completa])
    mapa = folium.Map(location=[avg_lat, avg_lon], zoom_start=8, height=600)
    folium.PolyLine(rota_completa, color="#007BFF", weight=5, opacity=0.8, popup="Rota da Estrada").add_to(mapa)
    folium.Marker(rota_completa[0], popup="Origem", icon=folium.Icon(color='green', icon='play')).add_to(mapa)
    folium.Marker(rota_completa[-1], popup="Destino", icon=folium.Icon(color='red', icon='stop')).add_to(mapa)
    if not df_carregadores_na_rota.empty:
        for _, carregador in df_carregadores_na_rota.iterrows():
            folium.CircleMarker(location=[carregador['AddressInfo.Latitude'], carregador['AddressInfo.Longitude']], radius=5, color='#003366', fill=True, fill_color='#003366', popup=carregador['AddressInfo.Title']).add_to(mapa)
    return mapa

style = {'description_width': 'initial'}
origem_cidade = widgets.Text(value='S√£o Paulo, SP', description='Cidade de Origem:', style=style)
destino_cidade = widgets.Text(value='Rio de Janeiro, RJ', description='Cidade de Destino:', style=style)
autonomia_slider = widgets.IntSlider(value=300, min=50, max=600, step=10, description='Autonomia (km):', style=style, continuous_update=False)
botao_simular = widgets.Button(description="Simular Rota e Gerar Mapa", button_style='success')
out_texto = widgets.Output()
out_mapa = widgets.Output()

def on_button_clicked_final(b):
    out_texto.clear_output()
    out_mapa.clear_output(wait=True)
    with out_texto:

        orig_coord = obter_coordenadas_por_endereco(ors_client, origem_cidade.value)
        dest_coord = obter_coordenadas_por_endereco(ors_client, destino_cidade.value)
        if not orig_coord or not dest_coord: return
        autonomia = autonomia_slider.value
        rota = obter_rota_real(ors_client, orig_coord, dest_coord)

        if rota:
            print("Rota obtida com sucesso! \nSimulando viagem...")
            resultado = simular_viagem_na_rota(rota, autonomia, df_publico)

            if resultado["viagem_viavel"]:
                print("\n Gerando mapa da rota...")
                with out_mapa:
                    mapa_resultado = desenhar_mapa_folium_real(resultado)
                    display(mapa_resultado)
            else:
                print("\n‚ùå Simula√ß√£o falhou.")
                if "autonomia_minima" in resultado:
                    print(f"Para completar o pr√≥ximo trecho, seu ve√≠culo precisaria de uma autonomia de pelo menos {resultado['autonomia_minima']} km.")
                print("N√£o foi poss√≠vel gerar um mapa para uma rota invi√°vel.")

botao_simular.on_click(on_button_clicked_final)

app_layout = widgets.VBox([
    widgets.Label('Insira a origem, destino e autonomia do ve√≠culo:'),
    origem_cidade,
    destino_cidade,
    autonomia_slider,
    botao_simular,
    out_texto, # √Årea para o texto
    out_mapa   # √Årea para o mapa
])

display(app_layout)

"""## 6. Conclus√£o

Este projeto demonstrou um fluxo completo de an√°lise de dados, desde a coleta e limpeza at√© o desenvolvimento de um prot√≥tipo interativo. As principais conclus√µes validaram nossas hip√≥teses iniciais:

1.  **Concentra√ß√£o Geogr√°fica (Hip√≥tese 1 Validada):** A an√°lise confirmou uma forte concentra√ß√£o de postos de recarga nas regi√µes Sul e Sudeste do Brasil, com S√£o Paulo liderando de forma proeminente. Regi√µes como Norte e Centro-Oeste apresentam "desertos de recarga", tornando viagens el√©tricas um grande desafio.

2.  **Escassez de Carregadores R√°pidos (Hip√≥tese 2 Validada):** A descoberta mais cr√≠tica foi a aus√™ncia de uma rede confi√°vel de carregadores r√°pidos (DC) de acesso p√∫blico nos dados. Isso representa o maior obst√°culo para a ado√ß√£o em massa de VEs para viagens de longa dist√¢ncia e foi classificado como um "Sinal Vermelho" para o viajante com pressa.

3.  **Viabilidade de Rotas Principais (Hip√≥tese 3 Validada):** Utilizando a rede de carregadores mais lenta (AC), a simula√ß√£o interativa provou que rotas principais, como S√£o Paulo-Rio de Janeiro, s√£o vi√°veis para ve√≠culos com autonomia de 300km. A ferramenta demonstrou, segmento a segmento, que existem op√ß√µes de recarga, embora exijam planejamento e paradas mais longas.

A ferramenta desenvolvida serve como um prot√≥tipo robusto que, com a integra√ß√£o de mais dados (como tempo de recarga e status em tempo real), poderia se tornar um produto de grande valor para motoristas de ve√≠culos el√©tricos no Brasil.
"""